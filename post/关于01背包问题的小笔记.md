# 关于01背包问题的小笔记

最近在看数据结构，准备系统地学一下相关知识，好为面试做准备。背包问题算是现在遇到的第一个经典算法题目。

## 正文

先是对于问题的定义：有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

然后我们通过问题可以知道（假设，whatever，这里讲的是01背包），每种物品有且仅有一件，可以选择拿，或者不拿。所以01就是这个意思，不拿就是0，拿就是1（我口胡的）。

老实讲，我一开始见到这个题目的时候是觉得有点手足无措的，因为看起来好像好简单，但是实际又不知道怎么做，在想了一会后发现，可以直接用组合，也就是枚举出所有情况来求最优解。暴力法的确是解决这个问题的其中一条路，不过也肯定存在更高效的办法，根据书本及搜索引擎，我知道了一个新的名词：动态规划。动态规划大概的意思是把多阶段过程转化为一系列单阶段问题，然后利用各阶段之间的关系，逐个求解。

回到背包问题这里，我们需要将整个过程抽象一下下，就是我们按顺序（这个顺序不重要，只是说要把东西一件件放到包里）把东西放进包，当手来到`i`件物品的时候，分析我们应不应该拿这一件物品：1，当选择不拿这件物品，那么包内的价值就是前`i-1`项物品所能得到的最大价值；2，当选择拿这件物品，则我们包就必须留一部分的容量出来放这件物品，那么包内的价值就应该是这一件物品的价值，加上包的剩余容量所能装的最大价值。这个过程用状态方程来表示就是`f(i, V)=max(f(i-1, V), f(i-1, V-w[i])+v[i])`，`f(i, V)`表达背包容量为`V`，拿到第`i`件物品的价值，等号右边的两项就是上面分析的两种情况。其实简单点讲就是，当前的最优解，需要前一个最优解来帮忙判断。

### 关于那个表

网上很多讲解都会附上一个表，我刚看的时候是看不懂的，主要是两个问题：

* 先是不懂为什么要填入那么多0，后来才想明白，最终的最优解是由之前的最优解推出来，之前的又由之前的之前的推，那么最之前的，也就是初始的最优解，是多少呢，这里将它设置为0，的确也符合直觉，0容量的背包所能装的价值应该为0。
* 想明白0的问题之后，然后不懂的这个表的那些非0数是怎么得到的，原来是要从上往下，从左往右来填，因为纵向表示我们一件件拿东西，按上面的分析，这一件东西拿不拿，取决于前一个最优解，也就是说，要填某个方格，这个数是它正上方的那个数，或者是它上方那一行，往左边偏移W列（看重量是多少）的那个数加上这件物品的价值，比较两者，谁大填谁。

最终，表的右下角就是01背包问题的解。

```python
# N 是总物品数， V 是背包总容量， 后面参数两个分别是每个物品对应的重量和价值
def bag_10(N, V, cost_list, worth_list): 
    if len(cost_list) == N:
        cost_list = list(cost_list)
        cost_list.insert(0, 0)
    if len(worth_list) == N:
        worth_list = list(worth_list)
        worth_list.insert(0, 0)
    # 上方的只是为了在最前面插入0
    
    res = [[ 0 for _ in range(V+1)] for _ in range(N+1)]  # 生成二维数组存储结果
    for i in range(1, N+1):
        for j in range(1, V+1):
            if cost_list[i] < j:
                res[i][j] = res[i-1][j]
            else:
            	res[i][j] = max(res[i-1][j], res[i-1][j-cost_list[i]] + worth_list[i])

    return res
```

中心思想就是遍历整个二维数组来填数，这里有一点要说，在内层循环中的判断是有必要的，如果`j-cost_list[i]`出现负值，会在错误的位置填数；而如果直接将内层循环的范围设为`range(cost_list[i], V+1)`，这样是不会出现负值，但是这一行前面的`cost_list[i]`列都会是0（初始值），所以也有可能会影响到后面的判断。

很容易分析到这个算法的时间复杂都是O(N * V)，空间复杂度是O(N * N)。网上大神说，时间复杂度是这样的了，不过空间复杂度是可以优化成O(N)，也就是用一维数组就够了。细细一想，一般情况下，我们是只想要最后的结果，而且每次求这一个最优解的时候，都是用上一行的最优解就够了，或者说，就是用这一格正上方的数，或者是上方左侧的某个数，也就是说，只要知道相邻的那行就可以用状态方程了，这样一想，发现好像的确是可以只用一维数组来存储。每次循环，都与这个数组中的数比较，然后更新对应位就行了。但是有一个地方要注意，我们求最优解的时候要用到上行的左侧某个数，而按上文填表的方式（从左到右），我们将会比较到是更新后的数，这不符合我们的方程，所以填表方式要做出改变，就是反向过来填，这样就保证了我们比较到的是上一行的那个数。

那么反向过来填会不会有其他问题呢，答案是不会。因为上一行是固定的（已生成好的，而最初的状态都是0），所以无论从左还是右开始填，比较的数都是一样的。

```python
def bag_10_one(N, V, cost_list, worth_list):
    if len(cost_list) == N:
        cost_list = list(cost_list)
        cost_list.insert(0, 0)
    if len(worth_list) == N:
        worth_list = list(worth_list)
        worth_list.insert(0, 0)
        
    res = [ 0 for _ in range(V+1)]
    for i in range(1, N+1):
        for j in range(V, cost_list[i]-1, -1):  # 倒序的目的是保证第i次循环中的F[i,v]是由F[i-1,v-Ci]递推而来的。保证每件物品只选一次。
            if j < cost_list[i]:                # 且如果是正序，用的就是新值了
                res[j] = res[j]
            else:
                res[j] = max(res[j], res[j-cost_list[i]] + worth_list[i])
                
    return res
```

而且这里提到了一个非常巧妙的技巧，是可以用到其他任何地方的：就是降维的用法。若仅需要保存前一项的数据，则用一维数组就够了。在二维数组表达中，每次是与之前一行的同位比较，在一维数组的表达中，每次是与同位比较，然后刷新同位。

### 填满背包

其实只要将初始状态的0设为负无穷就可以了。

`res = [ float('-inf') for _ in range(V+1)]  # 初始化一维数组的时候将0改为负无穷`

### 递归算法表达

```python
def bag_10_rec(i, j):  # i是第i件物品，j是剩余空间
    if i == -1:
        return 0
    if j < cost_list[i]:
        r = bag_10_rec(i-1, j)       
    else:
        r = max(bag_10_rec(i-1, j), bag_10_rec(i-1, j-cost_list[i]) + worth_list[i])
    return r
```

### 求出所选的物品

最简单的就是在填表过程中，额外用一个表来保存物品是否被选取的状态。

也可以根据已生成的结果来逆推：

```python
def reverse_trace(res, N, V):  # res是二维表
    i = N
    j = V
    while i > 0 and j > 0:
        if res[i][j] != res[i-1][j]:   # 选了第i个物品;与上一行的正上方比较，若相等则说明没有用第i项
            print("第%s个物品，空间：%s，价值：%s" % (i,c[i],v[i]))
            j -= c[i]  # 用了第i项的话，则要去到剩余空间那一列开始比较
        # 考察前一个物品，因为一个物品最多只会被用一次，所以递减去判断
        i -= 1
```

上面是用二维表来对表内元素进行比较，当然我们也可以只用结果来逆推出来：

```python
def knap_rec(res, cost_list, n):  # 逆向求出是哪几个数组成的res，这里的res是最优解那个值
    if res == 0: 
        return True
    if res < 0 or (res > 0 and n < 1):
        return False
    if knap_rec(res - cost_list[n-1], cost_list, n-1):
        print('Item' + str(n) + ':', cost_list[n-1])
        return True
    if knap_rec(res, cost_list, n-1):
        return True
    else: return False
```

这个算法是用到了状态方程表达出来的关系的。

### 类似问题

给一个整数的集合，要把它分成两个集合，要两个集合的数的和最接近。

#### 基本思路

都说了是类似问题，那么就是想办法把问题往背包问题那个形式靠。先把问题理解成我们要从一个集合里面取出元素，然后取出来的总值应该跟剩下的最接近。现在我们更近一步地转换题目，一共有N个元素，这里的元素的重量和价值是一样的，而背包容量V不超过集合的和的二分之一。所以最后转换成，在不超过背包容量V（集合的和的二分之一）这个前提下，求取出部分的最大值（最高价值），也就是其数字本身的和。

那么我们很容易得到：对于给定集合L，N=len(L)，V=sum(L)/2

```python
def bag_10_variant(L):
    N = len(L)
    HALF = sum(L)//2  # HALF就是V
    L = list(L)
    L.insert(0, 0)
        
    res = [0 for _ in range(HALF+1)]
    for i in range(1, N+1):
        for j in range(HALF, L[i]-1, -1):
            res[j] = max(res[j], res[j-L[i]] + L[i])
```


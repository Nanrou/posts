## E-tag

E-tag在通过中间件和装饰器设置，但是这两者并不完全相同，中间件是根据**整个响应**来计算哈希值的，也就说，是在服务器生成新的响应之后，比较新旧E-tag值，再选择是返回200还是304，而另一方面，装饰器生成E-tag值的原理是根据我们传进去的自定义函数来计算E-tag值，它会在比较之后，再决定是否运行被包裹的视图函数。

总的来说，如果是在中间件这个层面，服务器是已经走完整个流程来，到最后准备返回响应这一步，才利用E-tag来判断返回什么；而装饰器这个层面，则是先计算E-tag的值，有可能不运行视图函数就直接返回304。要注意的是，这并不是说用装饰器就一定比中间件好，这要看整个响应的内容，如果是很简单的内容，直接用中间件就好了，但是如果是一些复杂的内容，比如说一些是要根据请求参数来进行复杂计算的，可能在比较完参数后，直接返回而不需要再次重复计算会更好。

## 开发的快速原型

* 观察与分析，明确最终用户的目标
* 开发，先做出一个最小可行产品
* 部署，一定要方便每个人查看和测试
* 采纳和培训，对用户进行指导，并接受反馈
* 迭代和维护，根据反馈做出修改

## 静态网页

`SITE_PAGES_DIRECTORY`来指定静态网页的存放地址

用`django.utils._os`自带的`safe_join`来生成目标文件的地址，再用`django.temolate`中的`Template`类来根据文件内容生成对应模版内容

## 内置模版标签

`{% now 'Y' %}`就是当前的年份了

## bootstrap

通常需要我们自己来设置内边距

```css
body {
  padding: 50px 0;
}
```

## django-compressor

这个插件用来压缩静态文件。主要用法为，在模版文件中加对应标签。

## 模版变量的传参

除了直接在view中对模版的变量传值，还可以在子模版中，直接在继承的block块中以字典模式传值。

```
{% block context %}
{
    'a': 'value of a',
    'b': 'value of b',
}
{% endblock %}
```

## 前端验证

这里提出了一个新的理念，在用js框架写客户端时，通过前端js去判断用户是否已登陆，然后再决定渲染哪部分页面。不像普通服务端那样，显式地用login页面来辅助登陆管理。个人觉得，这种方法在静态站点上是可行的。因为前后端分离之后，后端不太可能再实时生成特定页面，这时候用json之类数据来告诉前端如何渲染也是一种选择。

## 服务端之间的交互

这里提到了面对不同需求时，采用不同的服务端去处理不同的需求，非常巧妙，Django负责主体，tornado则负责websocket部分，tornado可以通过暴露地址来接受Django或者客户端的指令，又或者是中间加一层，消息队列来分发任务。

## 整个项目的框架

Django的长处在于做CMS内容分发，而如果要用到websocket来处理一些实时更新交互的话，Django是有心无力的，因为它处理高并发的方法就是靠多线程，而我们又知道python的GIL限制，所以可以将这一部分需求分到另外一个服务器中去。tornado是基于事件循环的异步框架，专门为这种情况而设计的。

具体在这个项目中，客户端通过API去向Django要数据，然后通过tornado提供的基于websocket的双向交互，来保持与其他客户端的一致。

Django负责主体部分，主模版和所有API的支持，tornado则负责那些长链接，具体目的是协同那些需要在各客户端同步，但又不需要保存到数据库的信息。

文中还提到了，可以通过redis来加一层消息队列，这样子就可以开启多个tornado后端，提高容错和处理能力。


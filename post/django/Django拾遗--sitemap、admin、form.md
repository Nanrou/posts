# Django拾遗--pagination、sitemap、admin、form



## pagination

其实这个分页模块的原理就是根据设定的每页条数来分割`queryset`。查询结果/每页子项数目=页数

### 使用方法

传入实现了`__iter__`的object（一般来讲就是`queryset`)和期望的每页子项数给`Pagination`来生成分页处理器的实例。

根据这个分页生成器的page方法，传入页数就可以得到相应页数的内容。

`page = pagination.page(1)`

### 常用方法

生成器

`num_pages`：分页后的总页数

`page_range`：分页后总页数的迭代

分页对象

`has_next()/has_previous()`：判断前后是否还有

`next_page_number()/previous_page_number()`：前后的页数数字

常见异常处理

遇到超出页数范围时会抛出`emptypage`

### 个人踩坑

在做文章的前后翻页时，也用了这个，将每页子项数设为1，就可以达到效果。

但是这个生成的分页的页数是以1为base的，所以前后页的跳转url参数不能直接用页数。



## sitemap

最开始生成的sitemap是自己通过查数据库然后生成的，后面发现Django有内置的模块。

### 启用相关模块

把`django.contrib.sitemaps`加到`INSTALLED_APPS`中去。

已经启用了`sites framework`。

### 关于sites framework

其作用主要是提供一个钩子函数`get_current_site`来获取当前的主域信息。

实现原理是先在DB建立一个存放`site`信息的表，然后在`settings`文件中指明`site_id`，这样就可以在调用钩子函数时，根据这个id来得到对应的信息。

至于如何启用这个功能，先是将`django.contrib.sites`加到`INSTALLED_APPS`中，然后设置`SITE_ID`，然后执行`migrate`来生成表。

### 使用方法

其实具体实现起来跟普通视图大同小异，只是Django内置了一个专门处理这个的视图函数，也就是`django.contrib.sitemaps.views`中的`sitemap`，这是一个函数型的视图函数。

至于需要渲染出来的信息也是用Django内置的`Sitemaps`类包裹，其实就是在类中指明要查找的信息。

最后在配置URLCONF的时候，视图函数用内置的，参数Sitemaps用我们自己重写的，如果有自定义模版也一起附上就可以了。

当sitemap信息超过50000条的时候，需要分页，则需要用到sitemap的索引函数，暂时还没有这个需求，所以先不做。



## admin

### 启用相关模块

默认配置是启用了后台管理模块的，然后需要做的先是`manage.py createsuperusr`创建管理者用户，然后再URLCONF中配置好路由`url(r'^admin', admin.site.urls)`就可以了。

### 使用方法

在用后台管理之前，我要修改数据时，要么通过python调用Django的orm去操作数据库，要么通过数据库的相关管理软件来对数据库进行操作，后台管理的便利之处就在于可以在这个管理后台的页面对数据进行修改。（其实就是我暂时只知道能这样做，更多功能在有相关需求的时候再去挖掘吧）

既然这个后台管理是方便我们管理这些数据的，那么我们需要关注的地方就在选择展示哪些数据。如何展示呢，其实就是创建`admin.ModelAdmin`的子类，在这里面选择要展示的model（也就是那一个表），指出要展示的数据字段，展示规则，是否只读，排列顺序等各种配置。最后将这个子类和对应的model注册到`admin.site.register`里，这样在后台管理就能看到对应的信息了。

## form

Django内置了表单模块，用这个表单模块可以直接生成表单。

### 个人理解

Django内置了几种类，首先是Form类，这个类的申明跟model差不多，对每个字段进行定义，在view视图使用的时候就是将其实例化即可。

对原有的视图逻辑影响不大，只需要增加判断，在post请求的时候，将post内容传入给类生成实例，然后处理，跳转；在其他请求的时候，生成一个内容为空的实例，实际上就是在页面生成一个空的表单。

 在模版文件中，只需传入这个实例就可以自动生成表单了，当然一定要记得加上`{% csrf_token %}`这个，防止跨站伪造攻击。

然后就是Formset这个类，个人理解这个就是多个form加起来而已，也就是同时生成多个表单，个人在理解`max_num`和`extra`这个两个参数的时候有些犯浑，现在也记录一下，`max_num`是这些表单的总数，`extra`是生成的空白表单数，生成表单的时候，分为有初始值和无初始值，无初始值的那个表单个数就由`extra`决定，如果有初始值的表单个数大于或等于`max_num`，则`extra`这个参数等于没有用了，最终只会生成有初始值表单的个数，这个数是可以大于`max_num`的。

接着是ModelForm，这个类的好处在于根据已存在的model来生成form，类似继承，选择性继承字段，并且可以直接对已存在数据进行修改。不过也正是因为这样，验证数据的时候会有两步，先是验证表单数据，然后验证这个实例的数据与DB是否相符（表单数据类型是可以再定义的，所以不一定与model相等），注意的是，第一步完了之后会生成一个实例，如果在验证后需要更改数据的话，也需要改两次，一个是cleaned_data，一个是实例的。

最后是ModelFormset，这个暂时用不上，先放下。

在css和js方面，可以在class Media属性中设置自定义。
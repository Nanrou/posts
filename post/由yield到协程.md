# 由yield到协程

## yield

先要明白迭代器与生成器的区别，前者是根据已有对象来迭代，而后者是某种意义上的无中生有。

在具体语言表达中，迭代的循环体里，是这样的。

```python
for i in iter:
    operate i
```

而在生成器中，是有额外的关键字的。

```python
for i in gen:
   	yield operate i
```

在这两个for循环的背后，都是解释器不断地去调用 __ next  __ 方法来完成取值。在绝大多数情况下，这两者都能实现同样的功能，最多的差别也就在于一些内存的使用率上面。那为什么要有这两个东西呢，一个不就够了吗，答案是，生成器有普通迭代器没有的功能，生成器有一个很关键的方法：`send`。`send`能够接收数据，也就是说`yield`的左边是可以被操作的（`yield`的右边操作是由__ next __ 这个方法实现的）。

`y = yield x`这个语句应该分为两个部分理解，先是`yield x`，这个与普通情况下一样，都是返回一个对象，然后左边的话，就是`y`被赋值，被什么赋值呢，答案是被调用方用`send`方法传过来的值。

```python
def simple_coro(a):
    print('a:', a)
    b = yield a
    print('b:', b)
    c = yield b
    print('c:', c)
    yield c
```

要怎么调用`simple_coro`呢，先要用next方法，再用send方法，我们先看结果，再讲为什么这样调用。

```python
>>> coro = simple_coro(1)
>>> next(coro)
a:1
1
>>> coro.send(2)
b:2
2
>>> coro.send(3)
c:3
3
>>> coro.send(4)
.....StopIteration  # 会抛出迭代结束的异常
```

可以看到，我们用send方法来从外部对内部进行操作，而之所以可以这么操作，就是因为`yield`会暂停函数的运行，等待下一次调用，而下一次的调用也只运行到下一个`yield`处然后暂停。所以就像前面所说的，`y = yield x`这个语句是做了两件事的，返回值和赋值。所以我的理解是，在分析有`yield`关键字的语句时，将`yield`看成一个断句符，其左右是两个阶段，先执行右边的，再执行左边的。回到之前讲的，为什么先要调用next方法呢，就是将这个协程向前执行到第一个`yield`，也就是执行完第一个`yield`的右边，然后暂停在那里。

## yield from

我们可以从上一个例子看到，外部用send方法传值到协程内部，而内部用`yield`来返回值，而我们都知道，普通的函数返回值都是用`return`关键字的，那在协程内调用`return`会怎么样呢，`return`会在什么时候返回，以什么形式返回呢。

```python
def simple_coro(a):
    print('a:', a)
    b = yield a
    print('b:', b)
    c = yield b
    print('c:', c)
    yield c
    return a + b + c
```

以用之前那个例子好了，在最后一行加上`return`，看一下运行结果。

```python
...  # 与之前一样
>>> coro.send(3)
c:3
3
>>> coro.send(4)
.....StopIteration: 6  # return的值会包在停止异常里面
```

好了，谜题揭开了，`return`是可以用在协程里面的，返回的时机与普通函数的一样，但是形式有所不同，`return`返回的对象会被赋值为`StopIteration`这个异常的`value`，我们还是可以通过捕获异常，读取异常的值来得到这个`return`的值。

这个时候我们有请`yield from`出场，`yield from`这个新的关键字就是做了上述这个事情，捕获异常，并拿到异常中的值。除此之外，`yield from`还可以对右边的对象调用`iter`，从中获取迭代器。但是说到底，这些都不是`yield from`的主要职责，它的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，从而让双方能够交互。

PEP380中介绍的三层结构：最外层的调用方，作为中间通道的委派生成器，最内层的子生成器。如何区分这三者呢，简单来讲就是，调用方调用send方法去传值，委派生成器用`yield from`维持通道，子生成器用`yield`来接收和返回产出。

个人理解，所谓的维持通道，也就是委派生成器会在`yield from`那一行中阻塞，他不会知道调用方send的值，也不知道子生成器`yield`的值，但是会一直阻塞到右边的子生成器结束，然后获取子生成器抛出的异常中所带的返回值。

最后要注意的是，`yield from`是自带预激的，也就是在其内部实现中，是会先调用next方法来激活生成器。

## asyncio

协程，比线程更细粒。具体定义网上有很多，我就讲一下自己的理解：先是重申两个概念，并发与并行，前者指一次处理多件事，后者表示一次做多件事，而真正的并行量是依赖于CPU核心数的，由于系统调度的原因，我们可以并发100个进程，但是同一时间内真正被处理的进程数量是不会（能）大于CPU核心数的。这侧面反映了一个事实，就是某个进程，必须让出CPU，其他进程才会有机会被继续执行下去，如果不让出的话，就只能一直处理这个进程直到它结束才能去处理其他进程。对于IO操作来讲，就应该在等待IO的时候让出CPU，利用这个等待的时间去处理其他事情，等到IO响应的时候，再在其他事情让出CPU时，回来继续这个IO操作。进程、线程、协程在某种程度上是差不多的，只不过是后者比前者更细而已，多个线程或者协程并发运行的原理是与上面讲的是一致的。

至于协程包`asyncio`，它提出了官方的协程接口协议，也提供了事件循环，协程期物等有用的方法。多线程中，由主线程去运行由`Thread`对象实例化的子线程，而协程中则是由事件循环`loop`去运行已经包裹成`Task`类的协程`coro`或者期物`future`。

协程`coro`，期物`future`，任务`task`三者是不一样的，期物与线程库中期物类似，特指尚未完成的计算、还未执行的操作等；而协程虽然说是类似子线程这样的东西，但它并不是一个可以直接主动调用`start`的单位，它需要被动地被`await`或者`yield from`启动，但是，不可以直接在事件循环中用`await`或者`yield from`来启动一个协程（后面会讲为什么），不过一个协程可以被另一个已经启动的协程用`await`或者`yield from`来启动；前面说了不能直接在事件循环中启动协程，这是因为事件循环内的所有事件，都必须要先“注册”，才能被事件循环调用，而一个协程或者期物进行“注册”之后，它就会有一个新的名字，就是任务`task`，注册过的任务们，在启动事件循环后就会像多线程中的子线程那样，在事件循环中并行运行。而因为协程的粒度更小，所以其创建，销毁，维持的成本比线程小，所以并发选择协程会是更好的选择。

个人理解：透过现象看本质，一个协程是由它最内层的`yield`这种生成器来实现具体操作的，而我们（特指我这个普通人）要做也就是利用事件循环去驱动执行这些底层异步操作。